apply plugin: "c"
apply plugin: "assembler"

def COMPILER_ARGS = ["-g", "-march=nehalem", "-std=gnu99", "-ffreestanding", "-Wall", "-Werror", "-mno-red-zone", "-Wextra", "-DNDEBUG", "-include", "hal/debugger.h"]

model {
    platforms {
        intel {
            architecture "x86_64"
        }
    }
    toolChains {
        gcc(Gcc) {
            eachPlatform {
                assembler.executable = 'x86_64-elf-gcc'
                assembler.withArguments { args ->
                    args.remove "-x"  // this arguments is breaking the as
                    args.remove "assembler"  // this arguments is breaking the as
                    args.addAll COMPILER_ARGS
                    args << "-I$project.projectDir/src/kernel/headers"
                    args << "-I$project.projectDir/src/libk/headers"
                }
                cCompiler.executable = 'x86_64-elf-gcc'
                cCompiler.withArguments { args ->
                    args << "-I$project.projectDir/src/libk/headers"
                }
                linker.executable = 'x86_64-elf-ld'
                linker.withArguments { args ->
                    args.remove "-m64"  // this arguments is breaking the linker
                    args << "--discard-none"  // avoid remote debug symbols
                }
            }
        }
    }
    components {
        kernel(NativeExecutableSpec) {
            targetPlatform "intel"
            sources {
                asm {
                    source {
                        srcDirs "src/kernel/c"
                        include "**/*.S"
                    }
                }
                c {
                    source {
                        srcDirs "src/kernel/c", "src/libk/c"
                        include "**/*.c"
                    }
                }
            }
        }
    }
    binaries {
        all {
            cCompiler.args.addAll COMPILER_ARGS
            linker.args "-nostdlib", "-n", "-T", "src/kernel/c/hal/x86_64/linker.ld", "-L/usr/local/x86_64-elf/lib"
        }
    }
}

task run_tests(type:Exec) {
    description 'Run unity tests'
    FileTree tree = fileTree(dir: 'src', include: '**/test/**/*.c')
    inputs.files tree

    def test_compiler_args = []
    test_compiler_args.addAll COMPILER_ARGS
    test_compiler_args.remove "-Werror"
    test_compiler_args << "-Wno-unused-variable"
    test_compiler_args << "-Wno-unused-parameter"
    test_compiler_args << "-Wl,--warn-unresolved-symbols"
    test_compiler_args << "-I./unity/src unity/src/unity.c"
    test_compiler_args << "-I${project.projectDir}/src/kernel/headers"
    test_compiler_args << "-I${project.projectDir}/src/libk/headers"

    String script = """
    set -e
    UNITY_ROOT=${project.projectDir}/unity
    BUILD_DIR=${project.buildDir}/tests
    mkdir -p \$BUILD_DIR
    """
    tree.each { File file ->
        def sourceFiles = getSourceFiles(file.text, "${project.projectDir}/src")
        script += """
            ruby \$UNITY_ROOT/auto/generate_test_runner.rb ${file} \$BUILD_DIR/${file.name}
            gcc ${test_compiler_args.join(' ')}  ${file} \$BUILD_DIR/${file.name} ${sourceFiles.join(' ')} -o \$BUILD_DIR/${file.name}.run
            echo "Running ${file.name}"; \$BUILD_DIR/${file.name}.run
        """
    }
    commandLine "bash", "-c", script
}

def getSourceFiles(String text, String baseDir) {
    def matcher = text =~ '// source: (.*)'
    def result = []
    while (matcher.find()) {
        result << new File(baseDir, matcher.group(1))
    }
    return result
}
