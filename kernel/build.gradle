apply plugin: "c"
apply plugin: "assembler"

def COMPILER_ARGS = ["-g", "-march=nehalem", "-std=gnu99", "-ffreestanding", "-Wall", "-Werror", "-Wextra", "-DNDEBUG", "-mno-red-zone", "-include", "hal/debugger.h"]

model {
    platforms {
        intel {
            architecture "x86_64"
        }
    }
    toolChains {
        gcc(Gcc) {
            eachPlatform {
                assembler.executable = 'x86_64-elf-gcc'
                assembler.withArguments { args ->
                    args.remove "-x"  // this arguments is breaking the as
                    args.remove "assembler"  // this arguments is breaking the as
                    args.addAll COMPILER_ARGS
                    args << "-I$project.projectDir/src/kernel/headers"
                    args << "-I$project.projectDir/src/libk/headers"
                }
                cCompiler.executable = 'x86_64-elf-gcc'
                cCompiler.withArguments { args ->
                    args << "-I$project.projectDir/src/libk/headers"
                }
                linker.executable = 'x86_64-elf-ld'
                linker.withArguments { args ->
                    args.remove "-m64"  // this arguments is breaking the linker
                    args << "--discard-none"  // avoid remote debug symbols
                }
            }
        }
    }
    components {
        kernel(NativeExecutableSpec) {
            targetPlatform "intel"
            sources {
                asm {
                    source {
                        srcDirs "src/kernel/c"
                        include "**/*.S"
                    }
                }
                c {
                    source {
                        srcDirs "src/kernel/c", "src/libk/c"
                        include "**/*.c"
                    }
                }
            }
        }
    }
    binaries {
        all {
            cCompiler.args.addAll COMPILER_ARGS
            linker.args "-nostdlib", "-n", "-T", "src/kernel/c/hal/x86_64/linker.ld", "-L/usr/local/x86_64-elf/lib"
        }
    }
}

task run_tests {
    description 'Run unity tests'

    FileTree tree = fileTree(dir: 'src', include: '**/test/**/test_*.c')
    inputs.files tree

    def script
    def stdout = new ByteArrayOutputStream()

    doFirst {
        def test_compiler_args = []
        test_compiler_args.addAll COMPILER_ARGS
        test_compiler_args.remove "-Werror"
        test_compiler_args << "-Wno-unused-variable"
        test_compiler_args << "-Wno-unused-parameter"
        test_compiler_args << "-Wl,--warn-unresolved-symbols"
        test_compiler_args << "-I${project.projectDir}/src/kernel/test"
        test_compiler_args << "-I${project.projectDir}/unity/src"
        test_compiler_args << "-I${project.projectDir}/src/kernel/headers"
        test_compiler_args << "-I${project.projectDir}/src/libk/headers"
        test_compiler_args << "${project.projectDir}/unity/src/unity.c"

        script = """
        set -e
        UNITY_ROOT=${project.projectDir}/unity
        BUILD_DIR=${project.buildDir}/tests
        mkdir -p \$BUILD_DIR
        """
        tree.each { File file ->
            def sourceFiles = getSourceFiles(file.text, "${project.projectDir}/src")
            script += """
                echo "\n------------------ ${file.name} ------------------"
                echo ">>> Compiling..."
                ruby \$UNITY_ROOT/auto/generate_test_runner.rb ${file} \$BUILD_DIR/${file.name}
                gcc -m64 ${test_compiler_args.join(' ')} ${file} \$BUILD_DIR/${file.name} ${sourceFiles.join(' ')} -o \$BUILD_DIR/${file.name}.run
                echo ">>> Running: \$BUILD_DIR/${file.name}.run"
                \$BUILD_DIR/${file.name}.run 2>&1
            """
        }
    }

    doLast {
        exec {
            commandLine "bash", "-c", script
            standardOutput = System.out;
            errorOutput = System.err;
            ignoreExitValue = true;
        }
    }
}

def getSourceFiles(String text, String baseDir) {
    def matcher = text =~ '// source: (.*)'
    def result = []
    while (matcher.find()) {
        result << new File(baseDir, matcher.group(1))
    }
    result << "${project.projectDir}/src/kernel/test/kernel_mocks.c"
    return result
}
